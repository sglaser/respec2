//
// example of future configuration options of regpict
// regpictConf : 
{
    "width": 32,
    // name for unused fields. First is long name, Second is short name if long name won't fit.
    "unused": ["RsvdP", "R"],
    // size in pixels
    "cellWidth": 32,
    "cellHeight": 16,
    "cellInternalHeight": 8,
    // format of msb/lsb: e.g. [32,1] causes the string 1.19 to mean bit (1*32)+19
    "addrSize": [32, 1],
    // the generated SVG Element has this class
    "class": null,
    // describes a possible number rule that can be applied using applyRules
    // the '*' designates the name of a specific numberRule
    "numberRule*": {
        // inherits from the "parent" rule (e.g. "Foo" means "numberRuleFoo")
        "parent": null,
        // all Elements generated by this rule are an SVG <g> with this class
        "class": null,
        // position of this number rule relative to box portion of the diagram
        // valid values are top, bottom, left, right
        // left and right show if any of the bit numbers in the corresponding row are shown
        "position": "top,bottom,left,right",
        // offset of this number rule from the box portion of the diagram
        "offset": 0, // distance to numbers from word boxes
        // if false, hide all bit numbers regardless of other settings, does not affect lines
        "showNumbers": true,
        // if false, hide lines, regardless of other settings, does not affect bit numbers
        "showLines": true,
        // if true, show the most significant bit number of each field
        "msb": true,
        // if true, show the least significant bit number of every field
        "lsb": true,
        // formula that determines what additional bit numbers to show (in addition to lsb/msb)
        // first value is modulo, additional values are remainder values
        // show bits if (bit_number mod module) equals any of the remainder values
        // e.g. [8, 0, 7] means show the most and least significant bit number of each byte
        "mod": [8, 0, 7],
        // printf-style format for the bit number
        // null or empty string is the same as "%d"
        // valid strings are similar to: "%d", "%4d", "%04d", "+%d", "word %[div 32]d bit %d[rem 32]", "%x"
        // if present, the [...] is of either:
        //      [div N] -- value printed is floor(bit_number / N)
        //   or [rem N] -- value printed is bit_number - (floor(bit_number / N) * N)
        // where floor has the usual definition (floor(x) is the largest integer less than or equal to x)
        "fmt": "%d",
        // SVG style path for the lines around the bit numbers
        // no line are shown if this is null or the empty string
        // values can be expressions in parenthesis
        // the operators "+", "-", "*", and "/" are supported
        // arguments can be nested expressions, numbers, or the values: h or w
        // For this path, coordinate (0,0) is the upper left corner of the bit number area.
        // All SVG <path> items can be used. Absolute coordinates will be adjusted in the generated SVG Element.
        // h is the value of the register's cellHeight
        // w is the value of the register's cellWidth
        "linePath": "...",
        // position of the text within the bit number cell
        // x and y are integers or expressions in parenthesis (see linePath)
        "textPosition": [x, y],
        // position of the text pin location within the text string
        // x and y are integers or expressions.
        // h or w represent the bounding box of the text
        // The "textPinIn" point will coincide with the "textPositionIn"
        "textPin": [x, y]
    },
    // describes a possible field rule that can be applied using applyRules
    // the '*' designates the name of a specific numberRule
    "fieldRule*": {
        // inherits from the "parent" rule (e.g. "Foo" means "fieldRuleFoo")
        "parent": null,
        // all Elements generated by this rule are an SVG <g> with this class
        "class": null,
        // all <path> Elements generated by linePath* items in this rule are tagged with this class
        "class*": null,
        // SVG style path for the lines around the bit box
        // no line are shown if this is null or the empty string
        // values can be expressions in parenthesis
        // the operators "+", "-", "*", and "/" are supported
        // arguments can be nested expressions, numbers, or the values: h or w
        // For this path, coordinate (0,0) is the upper left corner of the bit box area.
        // All SVG <path> items can be used. Absolute coordinates will be adjusted in the generated SVG Element.
        // h is the value of the register's cellHeight
        // w is the value of the register's cellWidth
        // n is the number of field names (1 if name is a string, N if name is an array of length N)
        // x is the x coordinate of the upper left corner of the field name area
        // y is the y coordinate of the upper left corner of the field name area
        // if the field name fits in the bit box, x and y are both 0.
        // if the field name doesn't fit in the bit box, x and y are non-zero (and may be positive or negative)
        "linePath*": "...",
        // same as linePath but only applies to field names that fit in the bit box
        "linePathIn*": "...",
        // same as linePath but only applies to field names that don't fit in the bit box
        "linePathOut*": "...",
        // position of the first (or only) field name within the bit number cell
        // x and y are integers or expressions in parenthesis (see linePath)
        // applies when the field names fit in the bit box
        "textPositionIn": [x, y],
        // applies when the field names do not fit in the bit box
        "textPositionOut": [x, y],
        // Position of the text pin location within each field name
        // x and y are integers or expressions and represent the position of this field name
        // h or w represent the bounding box of this field name
        // H or W represent the bounding box of the longest field name for this field
        // Applies when field names fit in the bit box
        // The "textPinIn" point will coincide with the "textPositionIn"
        "textPinIn": [x, y],
        // Applies when field names do not fit in the bit box
        // The "textPinout" point will coincide with the "textPositionOut"
        "textPinOut": [x, y],
        // Offset from the a specific field name to the next field name for this field
        // Applies when field names fit in the bit box
        "textOffsetIn": [x, y],
        // Offset from the a specific field name to the next field name for this field
        // Applies when field names do not fit in the bit box
        "textOffsetOut": [x, y]
    },
    "useNumberRules": ["0", "1", "2"],
    "useFieldRules": ["0", "1", "2"],
    "fields": [
        {
            "msb": 0,
            "lsb": 0,
            "attr": "ro",
            "name": "Z"
        },
        {
            "msb": 2,
            "lsb": 1,
            "attr": "rw",
            "name": "bit_1_2"
        },
        {
            "msb": 3,
            "attr": "rw",
            "name": "bit3"
        },
        {
            "msb": 4,
            "name": "Ab",
            "attr": "rw"
        },
        {
            "name": "bit5",
            "msb": 5,
            "attr": "rw"
        },
        {
            "name": "bit6a",
            "msb": 6,
            "attr": "rw"
        },
        {
            "name": "bit7",
            "msb": 7,
            "attr": "rw"
        },
        {
            "name": "bit8",
            "msb": 8,
            "attr": "rw"
        },
        {
            "name": "bit9",
            "attr": "rw",
            "msb": 9
        },
        {
            "name": "bit14a",
            "attr": "rw",
            "lsb": 14
        }

    ]
}